<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Live Transcriber — In-Browser Vosk</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --gap:12px; --border:#e5e7eb; }
    *{ box-sizing:border-box }
    body{ margin:0; font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; }
    header{ display:flex; gap:var(--gap); align-items:center; padding:var(--gap); border-bottom:1px solid var(--border); flex-wrap:wrap; }
    header input{ flex:1 1 320px; padding:8px 10px; border:1px solid var(--border); border-radius:10px; }
    header button{ padding:8px 12px; border:1px solid var(--border); background:#111; color:#fff; border-radius:10px; cursor:pointer; }
    header button[disabled]{ opacity:.6; cursor:not-allowed; }
    main{ display:grid; grid-template-columns: 1.2fr 1fr; min-height: calc(100vh - 60px); }
    #player-wrap{ padding:var(--gap); }
    #player{ width:100%; max-width:960px; aspect-ratio:16/9; background:#000; }
    #transcript{ padding:var(--gap); border-left:1px solid var(--border); overflow:auto; }
    .line{ margin:8px 0; }
    .ts{ cursor:pointer; text-decoration:underline; margin-right:6px; }
    .meta{ color:#6b7280; font-size:12px; }
    .status-dot{ display:inline-block; width:10px; height:10px; border-radius:50%; background:#9ca3af; margin-right:6px; vertical-align:middle; }
    .status-dot.live{ background:#10b981; }
    .toolbar{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
    .note{ font-size:12px; color:#6b7280; }
  </style>

  <!-- YouTube player API -->
  <script src="https://www.youtube.com/iframe_api"></script>

  <!-- Vosk runtime -->
  <script src="https://unpkg.com/vosk-browser@0.0.8/dist/vosk.js"></script>
</head>
<body>
  <header>
    <input id="ytUrl" type="text" placeholder="Paste YouTube Live URL (optional)" />
    <button id="load" disabled>Load</button>

    <div class="toolbar">
      <button id="play">Play ▶</button>
      <button id="start">Start (pick tab/window)</button>
      <button id="stop">Stop</button>
      <button id="exportTxt">Export .txt</button>
      <button id="exportJson">Export .json</button>
    </div>

    <span class="meta"><span id="dot" class="status-dot"></span><span id="status">idle</span></span>
  </header>

  <main>
    <section id="player-wrap">
      <div id="player"></div>
      <div class="meta" style="padding:8px 0">
        1) <b>Load</b> your URL (button enables when player is ready) → 2) <b>Play ▶</b> → 3) <b>Start</b> and share the tab with audio.
      </div>
      <div class="note" id="modelNote">Model: not loaded</div>
    </section>
    <aside id="transcript"></aside>
  </main>

<script>
/* ====== Your GitHub Release model URL ====== */
const MODEL_URL = "https://github.com/iamhenrykeller-jpg/live-transcriber/releases/download/vosk/vosk-model-small-en-us-0.15.tar.gz";
/* ========================================== */

let player, playerReady = false;
let startedAt=0, mediaStream=null;
let audioCtx=null, srcNode=null, procNode=null;
let recognizer=null, modelLoaded=false;

/* ---------- YouTube loader with ready-gating & logs ---------- */
function onYouTubeIframeAPIReady(){
  player = new YT.Player('player', {
    height:'390', width:'640', videoId:'',
    playerVars:{
      autoplay:0, playsinline:1, modestbranding:1,
      origin: location.origin   // helps in some embed contexts
    },
    events:{
      onReady: () => {
        playerReady = true;
        console.log('[yt] ready');
        setStatus('YouTube player ready');
        // enable Load button
        document.getElementById('load').disabled = false;
        // auto-cue if URL already typed
        const v = document.getElementById('ytUrl').value.trim();
        if (v) doCue(v);
      },
      onError: (e) => {
        const code = e?.data;
        const msg = {
          2:'Invalid parameter (bad video ID/URL)',
          5:'HTML5 player error',
          100:'Video not found or removed',
          101:'Embedding disabled by owner',
          150:'Embedding disabled by owner'
        }[code] || ('Unknown error '+code);
        console.warn('[yt error]', code, msg);
        setStatus('YouTube error: ' + msg);
        alert('YouTube error: ' + msg);
      },
      onStateChange: (e) => {
        console.log('[yt state]', e.data); // 1 playing, 2 paused, 3 buffering, etc.
      }
    }
  });
}

function parseYouTubeId(url){
  try{
    const u = new URL(url);
    const v = u.searchParams.get('v');
    if (v && /^[A-Za-z0-9_-]{6,}$/.test(v)) return v;
    const m1 = u.hostname.includes('youtu.be') ? u.pathname.slice(1) : '';
    if (m1 && /^[A-Za-z0-9_-]{6,}$/.test(m1)) return m1;
    const m2 = u.pathname.match(/\/live\/([A-Za-z0-9_-]{6,})/);
    if (m2) return m2[1];
    const m3 = u.pathname.match(/\/embed\/([A-Za-z0-9_-]{6,})/);
    if (m3) return m3[1];
    return '';
  }catch{
    const bare = (url || '').trim();
    return /^[A-Za-z0-9_-]{6,}$/.test(bare) ? bare : '';
  }
}

function doCue(url){
  if (!playerReady) { console.warn('[yt] not ready yet, ignoring'); setStatus('Player not ready'); return; }
  const id = parseYouTubeId(url);
  if (id) {
    console.log('[yt] cue by id', id);
    player.cueVideoById(id);
    setStatus('Video cued by ID: ' + id);
  } else {
    try {
      console.log('[yt] cue by url', url);
      player.cueVideoByUrl(url);
      setStatus('Video cued by URL');
    } catch (e) {
      console.warn('[yt] cueVideoByUrl failed', e);
      setStatus('Could not load that URL');
      alert('Could not load that URL. Try https://www.youtube.com/watch?v=VIDEO_ID');
    }
  }
}

document.getElementById('load').onclick = () => {
  const url = document.getElementById('ytUrl').value.trim();
  doCue(url);
};

document.getElementById('play').onclick = () => {
  try { player?.playVideo?.(); setStatus('Play requested'); } catch(e){ console.warn('play failed', e); }
};

/* ---------- UI helpers ---------- */
function secToClock(sec){
  sec = Math.max(0, Math.floor(sec));
  const h = Math.floor(sec/3600), m = Math.floor((sec%3600)/60), s = sec%60;
  return (h? String(h).padStart(2,'0')+':' : '') + String(m).padStart(2,'0') + ':' + String(s).padStart(2,'0');
}
function addLine(text, startSec){
  if (!text) return;
  const div = document.createElement('div'); div.className = 'line';
  const a = document.createElement('span'); a.className = 'ts';
  a.textContent = '[' + secToClock(startSec) + ']';
  a.onclick = () => player?.seekTo && player.seekTo(startSec, true);
  const t = document.createElement('span'); t.textContent = ' ' + text;
  div.appendChild(a); div.appendChild(t);
  const pane = document.getElementById('transcript');
  pane.appendChild(div); pane.scrollTop = pane.scrollHeight;
}
function setStatus(msg, live=false){
  document.getElementById('status').textContent = msg;
  document.getElementById('dot').classList.toggle('live', !!live);
  console.log('[status]', msg);
}
function setModelNote(msg){
  document.getElementById('modelNote').textContent = msg;
}

/* ---- downsample Float32 to 16k Int16 for Vosk ---- */
function downsampleTo16k(float32Array, inSampleRate){
  const outRate = 16000;
  if (inSampleRate === outRate) {
    const out = new Int16Array(float32Array.length);
    for (let i=0;i<float32Array.length;i++){
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      out[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return out;
  }
  const ratio = inSampleRate / outRate;
  const newLen = Math.round(float32Array.length / ratio);
  const out = new Int16Array(newLen);
  for (let i=0;i<newLen;i++){
    const idx = i*ratio;
    const i0 = Math.floor(idx), i1 = Math.min(i0+1, float32Array.length-1);
    const frac = idx - i0;
    let s = float32Array[i0]*(1-frac) + float32Array[i1]*frac;
    s = Math.max(-1, Math.min(1, s));
    out[i] = s < 0 ? s*0x8000 : s*0x7FFF;
  }
  return out;
}

/* --------- Load Vosk model from your release --------- */
async function ensureVoskLoaded(){
  if (modelLoaded) return true;
  if (!window.Vosk) { alert("Vosk runtime not found."); return false; }

  setModelNote("Loading Vosk (first time can take 5–20s)...");
  if (Vosk.setLogLevel) Vosk.setLogLevel(0);

  const model = await Vosk.createModel(MODEL_URL);
  recognizer = new model.KaldiRecognizer(16000); // mono 16k
  modelLoaded = true;

  setModelNote("Model loaded ✔ (small EN)");
  return true;
}

/* ---------------- Start / Stop ---------------- */
document.getElementById('start').onclick = async () => {
  try{
    if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
      console.warn('Screen/tab capture needs HTTPS (GitHub Pages is OK).');
    }

    const ok = await ensureVoskLoaded();
    if (!ok) return;

    // Capture tab/window WITH audio
    const ms = await navigator.mediaDevices.getDisplayMedia({
      video: true,
      audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false }
    });
    // Only need audio
    const vt = ms.getVideoTracks()[0]; if (vt) vt.stop();
    const at = ms.getAudioTracks()[0];
    if (!at) { alert('No audio captured. Pick the tab with sound and check “Share tab audio”.'); return; }
    mediaStream = ms;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    srcNode = audioCtx.createMediaStreamSource(mediaStream);

    const bufSize = 4096; // tune 2048..8192 for latency/CPU
    procNode = audioCtx.createScriptProcessor(bufSize, 1, 1);
    procNode.onaudioprocess = (e) => {
      const ch0 = e.inputBuffer.getChannelData(0);
      const pcm16 = downsampleTo16k(ch0, audioCtx.sampleRate);
      recognizer.acceptWaveform(pcm16);
      const r = recognizer.result();
      if (r && r.text) {
        const secs = Math.floor((Date.now() - startedAt)/1000);
        addLine(r.text, Math.max(0, secs - 1));
      }
      // Optional partials:
      // const p = recognizer.partialResult();
      // if (p && p.partial) { /* show live partials */ }
    };

    srcNode.connect(procNode);
    procNode.connect(audioCtx.destination); // keep node alive

    startedAt = Date.now();
    setStatus('listening (local Vosk)…', true);
  }catch(err){
    setStatus('error: ' + (err?.message || String(err)), false);
  }
};

document.getElementById('stop').onclick = () => {
  try { procNode && procNode.disconnect(); } catch {}
  try { srcNode && srcNode.disconnect(); } catch {}
  try { audioCtx && audioCtx.close(); } catch {}
  try { mediaStream && mediaStream.getTracks().forEach(t => t.stop()); } catch {}
  setStatus('stopped', false);
};

/* ----------------- Exports ----------------- */
document.getElementById('exportTxt').onclick = () => {
  const lines = [...document.querySelectorAll('.line')].map(div => div.textContent.trim());
  const blob = new Blob([lines.join('\n')], {type:'text/plain'});
  const a = document.createElement('a'); a.href = URL.createObjectURL(blob);
  a.download = 'transcript.txt'; a.click(); URL.revokeObjectURL(a.href);
};
document.getElementById('exportJson').onclick = () => {
  const out = [...document.querySelectorAll('.line')].map(div => {
    const ts = div.querySelector('.ts')?.textContent?.replace(/\[|\]/g,'') || '00:00';
    const text = div.textContent.replace(/\[.*?\]\s*/, '').trim();
    return { ts, text };
  });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(new Blob([JSON.stringify({ lines: out }, null, 2)], {type:'application/json'}));
  a.download = 'transcript.json'; a.click(); URL.revokeObjectURL(a.href);
};
</script>
</body>
</html>
